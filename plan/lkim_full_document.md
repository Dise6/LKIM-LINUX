
# Linux Kernel Integrity Monitor (LKIM)
Полный технический документ (около 20–40 страниц в текстовом эквиваленте).  
Полностью совместим с Notion, Obsidian, GitHub и любым Markdown-редактором.

---

# 1. Введение

Linux Kernel Integrity Monitor (LKIM) — это учебно‑практический проект, задачей которого является исследование механизмов анализа целостности ядра Linux и обнаружения аномалий, связанных с изменением критически важных системных структур.  
LKIM распознаёт признаки возможного вредоносного вмешательства, анализируя состояние:

- модулей ядра,
- таблицы системных вызовов,
- параметров безопасности ядра (sysctl),
- таблицы символов ядра,
- критически важных бинарных файлов,
- процессов и скрытых процессов,
- каталога `/dev`,
- эталонных данных baseline.

Проект создан как учебная модель системы обнаружения rootkit‑активности, сочетающей архитектурный дизайн, алгоритмы анализа, механику baseline и модульность Unix‑подхода.

---

# 2. Цели и задачи проекта

Целями LKIM являются:

1. **Исследование структуры ядра Linux**  
   Через чтение `/proc`, таблиц, параметров, символов и модулей.

2. **Понимание принципов контроля целостности системного окружения**  
   Аналогичных tripwire, rkhunter, chkrootkit, auditd.

3. **Создание модульной архитектуры с baseline‑механизмом**  
   Позволяющей сравнивать состояние системы с эталоном.

4. **Формирование навыков проектирования, разработки и документирования ПО**  
   В соответствии со стандартами, применяемыми в индустрии.

5. **Работа с глобальными данными и системной информацией**  
   Понимание того, как события и объекты Linux связаны между собой.

---

# 3. Обоснование необходимости

Современные rootkit‑технологии часто изменяют:

- таблицу системных вызовов,
- таблицы символов,
- содержимое `/proc`,
- загружаемые модули,
- бинарные файлы системы,
- поведение ядра.

Большинство вредоносных модулей стремится скрывать процессы, файлы или подключённые модули.

LKIM показывает, как эти аномалии можно обнаруживать, используя только стандартные средства Linux.

---

# 4. Общая архитектура LKIM

```
lkim/
 ├── lkim.sh                  # главный модуль
 ├── core/
 │     ├── baseline.sh        # управление эталонами
 │     ├── logger.sh          # формирование отчётов
 │     ├── utils.sh           # вспомогательные инструменты
 │     └── ui.sh              # пользовательский интерфейс
 ├── checks/
 │     ├── modules.sh         # проверка модулей ядра
 │     ├── syscalls.sh        # таблица системных вызовов
 │     ├── binaries.sh        # целостность бинарных файлов
 │     ├── kernel_params.sh   # проверка параметров sysctl
 │     ├── kallsyms.sh        # таблица символов ядра
 │     ├── hidden_processes.sh# скрытые процессы
 │     └── devices.sh         # каталог /dev
 ├── baseline/                # эталонные данные
 ├── logs/                    # отчёты
 └── README.md
```

---

# 5. Принцип работы LKIM

## 5.1 Жизненный цикл проверки

```
Пользователь → UI → lkim.sh → модуль → baseline → сравнение → logger → отчёт
```

## 5.2 Единый протокол работы модулей

Каждый модуль:

1. Получает данные из системы.
2. Загружает baseline.
3. Сравнивает значения.
4. Формирует отчёт.
5. Передаёт результат в logger.

---

# 6. Подробное описание модулей

## 6.1 Модуль modules.sh — анализ модулей ядра

### Цель:
Определить, не были ли загружены или подменены модули ядра.

### Что проверяет:
- имена модулей,
- их размеры,
- параметры загрузки,
- зависимости.

### Алгоритм:
```
1. читать /proc/modules
2. сравнить со списком baseline
3. найти:
     - новые модули
     - исчезнувшие модули
     - изменившиеся параметры
4. сформировать отчёт
```

### Потенциальные угрозы:
- rootkit загружает модуль, скрывающий процессы;
- подмена сетевого драйвера.

---

## 6.2 syscalls.sh — анализ таблицы системных вызовов

### Задача:
Проверить, не были ли подменены системные вызовы (syscalls).

### Алгоритм:
```
1. выполнить ausyscall --dump
2. преобразовать вывод в таблицу "номер → имя"
3. сравнить с baseline
4. выявить:
     - новые вызовы
     - отсутствующие вызовы
     - изменение сопоставлений
```

### Пример rootkit‑атаки:
Перехват системного вызова open() для сокрытия файлов.

---

## 6.3 binaries.sh — контроль целостности бинарных файлов

### Задача:
Проверить системные команды:

- sudo  
- passwd  
- login  
- ls  
- ps  
- systemctl  
- netstat  
- ss  

### Методы:
- вычисление SHA256,
- сравнение веса файла,
- анализ структуры ELF.

### Алгоритм:
```
1. сформировать список бинарных файлов
2. вычислить хеши
3. сравнить с baseline
4. записать отклонения
```

---

## 6.4 kernel_params.sh — анализ параметров безопасности

Проверяемые параметры:

- kernel.randomize_va_space  
- kernel.kptr_restrict  
- kernel.modules_disabled  
- fs.suid_dumpable  
- kernel.dmesg_restrict  

### Алгоритм:
```
1. sysctl -a → текущие значения
2. загрузить baseline
3. сравнить значения
```

---

## 6.5 kallsyms.sh — анализ таблицы символов ядра

### Что анализируется:
- имена функций ядра,
- адреса,
- подозрительные символы,
- неизвестные адреса.

### Алгоритм:
```
1. считать /proc/kallsyms
2. обнаружить подозрительные имена
3. проверить диапазоны адресов
4. сравнить с baseline
```

---

## 6.6 hidden_processes.sh — поиск скрытых процессов

### Суть метода:
Если процесс есть в `/proc/<PID>`, но его нет в `ps -ef`, процесс скрыт.

### Алгоритм:
```
1. получить список PID из /proc
2. получить PID из ps
3. сравнить
4. выявить скрытые процессы
```

---

## 6.7 devices.sh — анализ каталога /dev

### Что проверяется:
- новые устройства,
- отсутствующие устройства,
- изменения прав доступа,
- подозрительные симлинки.

### Алгоритм:
```
1. просканировать /dev
2. загрузить baseline
3. сравнить списки
```

---

# 7. Механизм baseline

Baseline — эталонная модель системы.  
Создаётся в момент, когда система гарантированно чистая.

### Baseline содержит:
- список модулей,
- таблицу системных вызовов,
- хеши бинарных файлов,
- параметры ядра,
- таблицу символов,
- список устройств `/dev`.

### Создание baseline:
```
sudo ./lkim.sh --save-baseline
```

---

# 8. Алгоритмы работы с baseline

## 8.1 Формирование baseline
```
1. запустить все модули
2. собрать данные
3. сохранить в baseline/*
```

## 8.2 Сравнение с baseline
```
1. загрузить baseline-file
2. получить текущие значения
3. сравнить
4. сформировать diff
```

---

# 9. Логирование

Каждый модуль отправляет данные в logger:

```
logger.log("modules", "добавлен модуль xyz")
```

Формат отчётов:
```
[2025-02-14 10:23] MODULES: найден новый модуль xyz
```

---

# 10. Диаграммы ASCII

## 10.1 Архитектура
```
UI → lkim.sh → checks/* → baseline → сравнение → logger → отчёт
```

## 10.2 Поиск скрытых процессов
```
/proc  → список PID
ps     → второй список
сравнение → скрытые PID
```

## 10.3 Проверка бинарных файлов
```
файл → SHA256 → baseline → сравнение → вывод
```

---

# 11. Алгоритмы высокого уровня

## 11.1 Полная проверка системы
```
1. modules.sh
2. syscalls.sh
3. binaries.sh
4. kernel_params.sh
5. kallsyms.sh
6. hidden_processes.sh
7. devices.sh
8. log report
```

## 11.2 Обновление baseline
```
1. остановить проверки
2. собрать данные
3. перезаписать baseline/*
```

---

# 12. Пример сценария атаки и реакции LKIM

### Сценарий:
Rootkit перезаписывает бинарный файл `ps`.

### Действия LKIM:
1. binaries.sh вычисляет новый хеш.
2. baseline содержит оригинальный хеш.
3. файлы не совпадают.
4. logger сообщает:
```
Бинарный файл ps изменён. Возможная подмена.
```

---

# 13. Жизненный цикл разработки

1. Сбор требований  
2. Проектирование архитектуры  
3. Создание baseline-системы  
4. Разработка модулей  
5. Тестирование функционала  
6. Интеграция модулей  
7. Финальное тестирование  
8. Подготовка документации  
9. Поддержка и развитие  

---

# 14. Возможные направления развития

- Web‑панель мониторинга  
- Автоматическая отправка отчётов  
- Интеграция с auditd / SELinux  
- Создание базы сигнатур rootkit’ов  
- Реальное обнаружение хукнутых функций  

---

# 15. Заключение

LKIM — это учебный, но структурно серьёзный проект, демонстрирующий подходы к контролю целостности системных структур Linux. Он формирует практические навыки анализа, разработки модулей, работы с baseline и обработки системных данных.

---

# Конец документа
